---
title: "Why I Switched to Vibecoding"
date: 2026-02-10
tags: ["ai", "workflow", "productivity"]
description: "How AI-assisted coding changed my workflow and why I'm not going back."
draft: false
---

The term "vibecoding" gets a lot of eye-rolls. I get it. But after three months of building almost exclusively with Claude as my pair programmer, I'm convinced this is just how software gets built now.

## What Changed

I used to spend hours on boilerplate. Setting up a new project, wiring up APIs, writing tests for obvious behavior. Now I describe what I want, review the output, and focus my energy on the parts that actually need human judgment.

It's not about being lazy. It's about leverage.

## The Workflow

My typical session looks like this:

1. Open the terminal, describe the feature I want
2. Claude writes the initial implementation
3. I review, ask for changes, iterate
4. When it's working, I commit

The key insight: **the review step is where the real engineering happens.** You still need to understand what the code does. You still need to catch edge cases. But you're operating at a higher level of abstraction.

## What It's Bad At

Let's be honest about the limitations:

- Complex state management across multiple files still needs human orchestration
- Performance optimization requires understanding the specific runtime
- Anything involving deep domain knowledge that isn't well-represented in training data

## The Productivity Gap

I'm shipping roughly 3x more than I was six months ago. Not because the code is better â€” it's about the same quality. But because the friction of going from idea to working prototype has dropped dramatically.

The best tool is the one that gets out of your way. Right now, that's an AI in my terminal.
